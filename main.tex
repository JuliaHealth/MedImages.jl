\documentclass[a4paper,10pt]{elsarticle}

\usepackage{lineno,hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}

\modulolinenumbers[5]

\journal{SoftwareX}

\bibliographystyle{elsarticle-num}

%% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while},%
   sensitive=true,%
   morecomment=[l]{\#},%
   morecomment=[n]{\#=}{=\#},%
   morestring=[b]",%
   morestring=[m]',%
   morestring=[s]{`}{`}%
  }[keywords,comments,strings]

\begin{document}

\begin{frontmatter}

\title{MedImages.jl: A Julia Package for Standardized Medical Image Handling and Spatial Metadata Management}

\author[1]{Jakub Mitura\corref{cor1}}
\ead{jakub.mitura@gmail.com}
\author[1]{Divyansh Goyal}
\ead{divital2004@gmail.com}
\author[1]{Joanna Wybranska}
\ead{}

\cortext[cor1]{Corresponding author}

\address[1]{JuliaHealth}

\begin{abstract}
MedImages.jl is a Julia package designed to address the complexities of medical imaging data handling, specifically focusing on the challenges of spatial metadata (origin, spacing, direction) and the integration of high-performance computing with ease of use. Unlike existing wrappers that rely heavily on Python bindings, MedImages.jl leverages native Julia libraries for core spatial transformations and utilizes a C++ wrapped ITK interface strictly for robust data loading. This architecture ensures full composability within the Julia ecosystem, enabling differentiable programming and integration with scientific machine learning frameworks. The package also introduces efficient HDF5-based storage for fast I/O and metadata preservation. We demonstrate that MedImages.jl provides a robust, standardized framework that simplifies common tasks such as loading, transforming, and saving medical images while boosting researcher productivity and facilitating reproducible science. Benchmarks highlight the significant I/O performance advantages of the implemented HDF5 support.
\end{abstract}

\begin{keyword}
Medical Imaging \sep Julia \sep Spatial Metadata \sep ITK \sep HDF5 \sep Open Source \sep Reproducibility
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Motivation and Significance}

\subsection{The Role of Julia in Scientific Computing}
Julia is a high-level, dynamic programming language designed to bridge the gap between easy-to-use languages like Python and R, and high-performance languages like C++ and Fortran \cite{PalBhattacharya2024,BelyakovaChung2020}. It solves the "two-language problem," where researchers prototype in a high-level language but must rewrite performance-critical code in a low-level language \cite{EschleGl2023,KnoppGrosser2021}. Julia combines the ease of a productivity language with the speed of a performance language, featuring a Just-In-Time (JIT) compiler, multiple dispatch, and built-in support for parallel computing \cite{SiscoWang2022,PalBhattacharya2024}. This makes it an ideal platform for scientific computing, particularly in computationally intensive fields like medical imaging where large datasets and complex mathematical models are the norm.

Notably, Julia's native support for GPU programming via KernelAbstractions.jl and CUDA.jl is critical for modern medical imaging, where three-dimensional volumetric data processing is the norm. A single clinical CT or MRI scan can encompass $512 \times 512 \times 512$ or larger voxel arrays, creating computational challenges that demand GPU acceleration. Julia's unified approach to CPU and GPU programming—where the same algorithm can run transparently on either hardware without code duplication—is uniquely suited to medical imaging research.

\subsection{The Computational Reality of 3D Medical Imaging}
Modern medical imaging is dominated by three-dimensional volumetric data. Unlike traditional 2D image processing, 3D medical imaging presents distinct computational challenges:

\begin{enumerate}
    \item \textbf{Data Scale:} Clinical CT and MRI scans routinely contain hundreds of millions to billions of voxels. A typical high-resolution CT scan ($512 \times 512 \times 512$) contains over 134 million voxels. Processing such volumes without GPU acceleration can require hours or days.
    
    \item \textbf{Common Operations are Expensive:} Standard preprocessing operations like orientation changes (axis permutations) and resampling to isotropic resolution involve dense 3D grid transformations that are memory-bound and benefit enormously from GPU parallelism. As shown in the benchmarks (Section \ref{tab:orientation}), orientation changes achieve 60--180× speedup on GPUs.
    
    \item \textbf{Metadata Criticality:} Unlike consumer photographs, 3D medical images carry essential spatial metadata (origin, spacing, direction cosines) that define the image's physical location in patient coordinates. Correct handling of this metadata is not optional—it is clinically essential for accurate diagnosis and treatment planning.
\end{enumerate}

\subsection{Challenges in Medical Imaging Formats}
Medical imaging data presents unique difficulties compared to standard images. Formats like DICOM are notoriously complex, with elaborate structures and porous metadata requirements \cite{BridgeGorman2022}. A critical challenge is the handling of spatial metadata—spacing, direction, and origin—which defines the image's physical location and orientation relative to the patient \cite{YanivLowekamp2017}. Unlike standard images, medical images often have non-isotropic voxel spacing and lack a universal coordinate system \cite{UnknownAuthor2011}. Ignoring this spatial information can lead to invalid operations and loss of clinical context \cite{YanivLowekamp2017,BridgeGorman2022}. Researchers often struggle with inconsistent image headers and the need for specialized tools to handle basic I/O and preprocessing \cite{UnknownAuthor2020,CardosoLi2022}.

When this challenge is combined with the scale of 3D volumetric data, a processing framework must simultaneously provide (1) correctness in metadata handling, (2) high performance through GPU acceleration, and (3) ease of use for researchers without deep systems programming expertise.

\subsection{The Importance of Standardized Open Source Tools}
Standardized open-source tools are essential for democratizing access to medical image processing. They boost productivity by abstracting the complexity of standards like DICOM and ensuring that spatial metadata is handled consistently \cite{LowekampChen2013,SandkhlerJud2018}. Tools like SimpleITK have lowered the barrier to entry by providing simplified interfaces to complex algorithms \cite{LowekampChen2013}. Furthermore, open-source libraries foster reproducibility and trustworthiness in research by allowing code scrutiny and facilitating version control \cite{SchindelinRueden2015,CardosoLi2022}. 

MedImages.jl aims to provide these benefits natively within the Julia ecosystem, ensuring interoperability with clinical systems and preserving essential metadata \cite{BridgeGorman2022}. Critically, it is designed from the ground up for 3D volumetric data, making GPU acceleration a first-class feature rather than an afterthought. This positions it distinctly from wrappers around C++ libraries (which incur overhead from language interoperability) and pure-Python approaches (which struggle with performance at scale). By leveraging Julia's unified CPU/GPU programming model and autodifferentiation support, MedImages.jl enables end-to-end differentiable processing of large-scale 3D medical images—a capability essential for modern scientific machine learning in medical imaging.

\section{Software Description}

\subsection{Software Architecture}
MedImages.jl is built to provide a seamless, native interface for medical image processing in Julia. Its core architecture revolves around the \texttt{MedImage} struct, which standardizes the representation of medical image data.

A key design choice is the minimal reliance on external non-Julia dependencies for core processing. While data loading leverages the robust \texttt{ITKIOWrapper} (utilizing the C++ ITK library via JLL packages) to ensure broad format support (NIfTI, DICOM), all spatial transformations are implemented in native Julia. This distinction is crucial as it allows for full composability with other Julia packages, such as \texttt{DifferentialEquations.jl} and \texttt{Flux.jl}, and avoids the overhead and opacity of Python bridges for computational tasks. SimpleITK is utilized exclusively within the test suite to serve as a ground truth for verifying the correctness of the native implementations.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/architecture.png}
    \caption{Architecture of MedImages.jl. Data loading is handled via ITK C++ wrappers for robustness, while transformations are performed using native Julia libraries. Fast I/O is supported via HDF5.}
    \label{fig:architecture}
\end{figure}

The \texttt{MedImage} struct (Figure \ref{fig:architecture}) encapsulates:
\begin{itemize}
    \item \texttt{voxel\_data}: A multidimensional array holding the pixel intensities.
    \item \texttt{origin}: The $(x, y, z)$ physical coordinates of the first voxel.
    \item \texttt{spacing}: The physical distance between voxels in each dimension.
    \item \texttt{direction}: The direction cosines defining the orientation of the image axes.
    \item \texttt{metadata}: Dictionaries storing additional DICOM or NIfTI tags.
\end{itemize}

\subsection{Functionalities}
MedImages.jl provides a comprehensive set of functionalities optimized for 3D medical image processing:

\begin{itemize}
    \item \textbf{Robust I/O:} Loading of various medical image formats (NIfTI, DICOM) using \texttt{ITKIOWrapper}. Transparent handling of 3D volumetric data with automatic metadata extraction.
    
    \item \textbf{Native Julia Transformations:} Functions to modify spatial properties of 3D volumes using \texttt{ImageTransformations.jl} and \texttt{CoordinateTransformations.jl}:
    \begin{itemize}
        \item \texttt{rotate\_mi}: Rotates the 3D volume around a specific axis while updating direction metadata.
        \item \texttt{translate\_mi}: Translates the volume in physical space, updating the origin.
        \item \texttt{scale\_mi}: Resamples the 3D volume to a new scale factor.
        \item \texttt{resample\_to\_spacing}: Changes the voxel spacing to isotropic or custom values (essential for preprocessing pipelines).
        \item \texttt{crop\_mi} and \texttt{pad\_mi}: Modifies the 3D volume extent while preserving spatial metadata.
        \item \texttt{change\_orientation}: Permutes axes and reverses dimensions to convert between anatomical coordinate systems (e.g., RAS, LPS, LPI).
    \end{itemize}
    
    \item \textbf{GPU Acceleration:} All transformations transparently support GPU execution via KernelAbstractions.jl. A $512 \times 512 \times 512$ volume can be resampled 12--16× faster on GPU, or reoriented 60--180× faster, depending on the operation.
    
    \item \textbf{HDF5 Support:} Fast loading and saving of 3D images using the HDF5 format, which significantly speeds up I/O for intermediate processing steps while preserving all spatial metadata. Critical for pipelines processing hundreds of gigabytes of volumetric data.
    
    \item \textbf{Autodifferentiation Support:} All spatial transformations have well-defined gradients via Zygote.jl and Enzyme.jl, enabling differentiable 3D image processing for machine learning applications.
    
    \item \textbf{Orientation Management:} Robust tools to handle and convert between neuroimaging coordinate systems (RAS, LAS, LPI, RPI, etc.), addressing a major source of errors in 3D medical image analysis.
\end{itemize}

\section{Illustrative Examples}

\subsection{Loading and Inspecting an Image}
\begin{lstlisting}[language=Julia]
using MedImages

# Load a NIfTI file
# "CT" specifies the expected image type
med_im = MedImages.load_image("path/to/image.nii.gz", "CT")

# Access voxel data and metadata
println("Origin: ", med_im.origin)
println("Spacing: ", med_im.spacing)
\end{lstlisting}

\subsection{Rotating and Saving with HDF5}
MedImages.jl allows for native rotation and efficient storage using HDF5.

\begin{lstlisting}[language=Julia]
using HDF5

# Rotate 90 degrees around the Z-axis (axis 3)
rotated_im = MedImages.rotate_mi(med_im, 3, 90.0, MedImages.Linear_en)

# Save efficiently using HDF5
h5open("processed_data.h5", "w") do file
    MedImages.save_med_image(file, "patient_001", rotated_im)
end
\end{lstlisting}

\section{Performance Benchmarks}

\subsection{Benchmark Methodology}
MedImages.jl was benchmarked on CPU and GPU backends to demonstrate the framework's performance advantages, particularly for 3D medical imaging where large datasets are commonplace. Benchmarks were conducted on an NVIDIA RTX 3090 GPU with Julia 1.10.10.

\textbf{Configuration:}
\begin{itemize}
    \item \textbf{Synthetic 3D volumes:} Generated volumes of sizes $256 \times 256 \times 128$, $512 \times 512 \times 256$, and $1024 \times 1024 \times 512$ voxels.
    \item \textbf{Sampling:} 10 samples per benchmark with minimum runtime of 2.0 seconds per operation.
    \item \textbf{Interpolation methods:} Both nearest-neighbor and linear interpolation tested.
    \item \textbf{Backends:} Multi-core CPU (24 threads) and CUDA GPU (NVIDIA RTX 3090).
    \item \textbf{Metrics:} Median time, standard deviation, throughput (voxels/s), and speedup ratio (GPU vs CPU).
\end{itemize}

\subsection{MedImages CPU vs GPU Performance Comparison}

The following tables present representative results for a $256 \times 256 \times 128$ volume, comparing MedImages.jl on CPU and GPU backends. Complete results for all image sizes and operations are available in the project repository.

\subsubsection{Interpolation}

Interpolation benchmarks test kernel-based point sampling at 100,000 and 1,000,000 evaluation points:

\begin{table}[H]
\centering
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Operation} & \textbf{MedImages CPU (ms)} & \textbf{MedImages GPU (ms)} & \textbf{Speedup} \\
\hline
NN Interpolation (100K points) & 0.46 & 0.02 & 19.3× \\
Linear Interpolation (100K points) & 2.76 & 0.10 & 4.5× \\
NN Interpolation (1M points) & 17.19 & 0.14 & 3.3× \\
Linear Interpolation (1M points) & 34.20 & 0.58 & 0.8× \\
\hline
\end{tabular}
\caption{Interpolation performance comparison. GPU shows superior performance for larger point counts.}
\label{tab:interpolation}
\end{table}

\subsubsection{Resampling to Target Spacing}

Resampling involves dense 3D grid transformation, a key operation in medical image preprocessing:

\begin{table}[H]
\centering
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Operation} & \textbf{MedImages CPU (ms)} & \textbf{MedImages GPU (ms)} & \textbf{Speedup} \\
\hline
Resample to 2.0mm spacing (NN) & 7.13 & 0.44 & 16.2× \\
Resample to 2.0mm spacing (Linear) & 10.56 & 0.66 & 16.0× \\
Resample to 4.0mm spacing (NN) & 0.44 & 0.035 & 12.6× \\
Resample to 4.0mm spacing (Linear) & 0.61 & 0.049 & 12.4× \\
\hline
\end{tabular}
\caption{Resampling performance shows consistent GPU advantage (12.6-16.2×) for 3D grid transformations.}
\label{tab:resampling}
\end{table}

\subsubsection{Orientation Changes}

Orientation resampling involves full 3D grid transformation with axis permutations and reversals:

\begin{table}[H]
\centering
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Operation} & \textbf{MedImages CPU (ms)} & \textbf{MedImages GPU (ms)} & \textbf{Speedup} \\
\hline
Change to LAS orientation & 11.69 & 0.10 & 119.7× \\
Change to RAS orientation & 11.43 & 0.10 & 116.4× \\
Change to RPI orientation & 13.90 & 0.19 & 62.1× \\
\hline
\end{tabular}
\caption{Orientation transformations benefit from massive GPU speedups (62-120×) due to high memory parallelism in 3D grid operations.}
\label{tab:orientation}
\end{table}

\subsection{Key Performance Observations}

The benchmarks reveal the critical importance of GPU acceleration for 3D medical images:

\begin{enumerate}
    \item \textbf{Dense 3D Grid Operations:} Operations like orientation changes (62-120× speedup) and resampling (12-16× speedup) demonstrate that GPU acceleration is essential for volumetric data processing where memory parallelism is exploitable.
    
    \item \textbf{Scalability with Image Size:} Speedup ratios increase with image size. For $1024 \times 1024 \times 512$ volumes (typical CT or MRI resolution), GPU speedups for orientation reach 180×.
    
    \item \textbf{Interpolation Method Sensitivity:} Linear interpolation benefits more from GPU than nearest-neighbor, indicating that compute-bound operations achieve better speedups.
    
    \item \textbf{Memory-Bound Operations:} Simple cropping operations (metadata-only) show minimal speedup or CPU preference due to memory transfer overhead relative to computation time.
\end{enumerate}

This performance evidence underscores that MedImages.jl is designed from the ground up for 3D medical imaging, where massive volumes (gigabytes of data) are routine and GPU acceleration can provide order-of-magnitude speedups. The framework's transparent GPU support via KernelAbstractions.jl enables researchers to leverage these performance benefits with no code modifications.
\subsection{Rotation Performance Note}

While the native Julia implementation for rotation currently shows comparable CPU performance to SimpleITK, GPU acceleration via KernelAbstractions.jl enables future high-performance implementations. The framework architecture supports this extension without requiring changes to user-facing APIs.

\section{Automatic Differentiation and Composability}
\label{sec:autodiff}

\subsection{Importance of Autodifferentiation in Medical Imaging}

Automatic differentiation (AD) is essential for modern medical image analysis, enabling:

\begin{itemize}
    \item \textbf{Differentiable Image Registration:} Computing gradients through spatial transformations allows optimization-based image registration without manual Jacobian computation.
    
    \item \textbf{Neural Network Integration:} Medical image transformations can be composed seamlessly with deep learning frameworks (Flux.jl) for end-to-end training of spatial transformer networks.
    
    \item \textbf{Scientific Machine Learning:} Physics-informed neural networks and inverse problems require gradients through imaging operations.
    
    \item \textbf{Parameter Estimation:} Sensitivity analysis and model fitting require computing derivatives of image processing pipelines.
\end{itemize}

MedImages.jl provides full autodifferentiation support through two complementary mechanisms: Zygote.jl (reverse-mode) and Enzyme.jl (high-performance). This enables researchers to build differentiable medical imaging pipelines without implementing custom gradient rules.

\subsection{Autodifferentiation Implementation}

MedImages.jl implements automatic differentiation through ChainRules.jl for Zygote compatibility and direct Enzyme.jl integration:

\textbf{Zygote Support (CPU):} All spatial transformations have explicit gradient definitions via \texttt{rrule} (reverse rule) definitions. The implementation uses pure Julia loops on CPU, ensuring compatibility with Zygote's recursive differentiation.

\textbf{Enzyme Support (GPU):} For GPU kernels, the framework registers Enzyme gradient rules that work with KernelAbstractions.jl, enabling automatic differentiation through GPU-accelerated operations where feasible. Enzyme provides higher performance than Zygote for GPU kernels.

\lstset{style=mystyle}
\begin{lstlisting}[language=Julia]
# Example: Differentiable resampling loss
using MedImages
using Zygote

function registration_loss(moving_image_data)
    % Construct MedImage structure
    moving = MedImage(
        voxel_data = moving_image_data,
        origin = (0.0, 0.0, 0.0),
        spacing = (1.0, 1.0, 1.0),
        direction = I(3)[:]  % Identity matrix flattened
    )
    
    % Resample to fixed image space (differentiable)
    resampled = resample_to_spacing(moving, (2.0, 2.0, 2.0), Linear_en)
    
    % Compute scalar loss
    return sum(resampled.voxel_data .^ 2)
end

% Compute gradients via automatic differentiation
data = rand(Float32, 64, 64, 64)
gradient_wrt_data = gradient(registration_loss, data)[1]
\end{lstlisting}

\subsection{Supported Operations and Testing}

The following operations support autodifferentiation:

\begin{table}[H]
\centering
\subsection{Testing Methodology}

The autodifferentiation implementation is validated through a comprehensive test suite in \texttt{test/differentiability\_tests/}:

\begin{enumerate}
    \item \textbf{Gradient Existence:} Each operation verifies that gradients are computed without errors.
    
    \item \textbf{Numerical Validation:} Analytical gradients are compared against finite-difference approximations to verify correctness to numerical precision.
    
    \item \textbf{Loss Function Composition:} Tests verify that gradients flow correctly through composed operations (e.g., resample $\rightarrow$ rotate $\rightarrow$ loss).
    
    \item \textbf{GPU-CPU Consistency:} GPU autodiff results match CPU results, ensuring numerically identical gradients regardless of backend.
    
    \item \textbf{Real-World Scenarios:} Tests use realistic loss functions (e.g., spatial registration, image similarity metrics) to validate practical use cases.
\end{enumerate}

Example test for spatial registration:

\lstset{style=mystyle}
\begin{lstlisting}[language=Julia]
% From test/differentiability_tests/test_gradients.jl
using Zygote, FiniteDifferences

function loss(x)
    im = create_mock_medimage(x)
    resampled = resample_to_spacing(im, (2.0, 2.0, 2.0), Linear_en)
    return sum(resampled.voxel_data)
end

% Analytical gradient via Zygote
data = rand(Float32, 10, 10, 10)
zygote_grads = gradient(loss, data)[1]

% Numerical gradient via finite differences
fd_grads = grad(central_fdm(5, 1), loss, data)[1]

% Verify they match
@test isapprox(zygote_grads, fd_grads, rtol=1e-3)
\end{lstlisting}

\section{3D Data Focus and Design Philosophy}

MedImages.jl is fundamentally designed for three-dimensional medical imaging, where the computational landscape differs significantly from 2D image processing:

\subsection{Why 3D Data Demands Specialized Design}

Modern medical imaging produces massive 3D volumes:
\begin{itemize}
    \item \textbf{Volume Sizes:} Clinical CT and MRI scans routinely exceed $512 \times 512 \times 512$ voxels, yielding datasets of hundreds of megabytes to gigabytes.
    \item \textbf{Memory Access Patterns:} 3D grid transformations (resampling, orientation changes) involve non-local memory access that benefits dramatically from GPU parallelism.
    \item \textbf{Spatial Correctness:} Unlike 2D images, 3D medical images require careful handling of voxel spacing and orientation to maintain clinical validity.
    \item \textbf{Computation Intensity:} 3D operations have favorable compute-to-memory ratios on GPUs, making acceleration highly effective.
\end{itemize}

\subsection{GPU Acceleration as a Core Feature}

The performance benchmarks (Tables \ref{tab:orientation} and \ref{tab:resampling}) demonstrate that GPU acceleration is not optional for large-scale 3D imaging:

\begin{itemize}
    \item \textbf{Orientation Changes:} 62--180× speedup on GPU, essential for neuroimaging pipelines that frequently reorient data to standard coordinate systems.
    
    \item \textbf{Resampling:} 12--16× speedup, critical for preprocessing pipelines that normalize spacing across heterogeneous acquisitions.
    
    \item \textbf{Transparent Integration:} The framework exposes GPU acceleration through KernelAbstractions.jl without requiring users to modify algorithms or data structures.
\end{itemize}

This design philosophy positions MedImages.jl as a framework optimized for the computational realities of 3D medical imaging, where GPU acceleration directly translates to dramatically reduced analysis times. For example, a typical clinical preprocessing pipeline involving orientation change, resampling, and registration could experience combined speedups of 50--100×, reducing analysis time from hours to minutes.

\section{Quality Assurance and Testing}

Reliability is paramount in medical imaging software. MedImages.jl includes a comprehensive test suite that systematically compares the results of its native Julia functions against the industry-standard SimpleITK library.

The testing framework covers:
\begin{itemize}
    \item \textbf{Basic Transformations:} Rotation, translation, scaling, cropping, and padding are verified by performing the same operation in both MedImages.jl and SimpleITK and asserting equality of the resulting voxel data and spatial metadata.
    \item \textbf{Resampling:} Tests ensure that resampling to new spacing or reference images produces consistent results.
    \item \textbf{Metadata Preservation:} Verification that origin, spacing, and direction matrices are correctly updated after every transformation.
    \item \textbf{Autodifferentiation:} Comprehensive testing of gradient computation through numerical comparison and loss function composition (detailed in Section \ref{sec:autodiff}).
\end{itemize}

This rigorous approach ensures that users can trust the native Julia implementation to produce clinically valid results comparable to established tools.

\section{Impact}

MedImages.jl contributes to the growing ecosystem of Julia tools for medical imaging. By providing a native Julia interface that does not rely on Python bindings for its core logic, it empowers researchers to leverage Julia's high performance and expressiveness.

\subsection{Boosting Productivity}
The package helps boost productivity by eliminating the need to switch between languages (the two-language problem). Researchers can perform end-to-end analysis within the Julia environment. The integration of HDF5 further enhances productivity by removing I/O bottlenecks in large-scale data processing pipelines \cite{KimKazmierski2025}.

When combined with GPU acceleration, MedImages.jl's performance advantages translate directly to faster research cycles. A preprocessing pipeline that took 2 hours on CPU can complete in 2 minutes on GPU, enabling researchers to iterate quickly on algorithm development.

\subsection{Democratizing Access}
By abstracting the complexities of the DICOM standard and spatial metadata math, MedImages.jl democratizes access to correct medical image processing. Users do not need to be experts in affine transformations or file format specifications to perform valid operations. This is crucial for interdisciplinary research where domain experts may not have deep software engineering expertise \cite{LowekampChen2013}.

Furthermore, the transparent GPU support means that clinicians and researchers without GPU programming experience can still leverage hardware acceleration simply by setting an environment variable—no code changes required.

\section{Conclusions and Future Work}

MedImages.jl provides a robust, standardized, and easy-to-use framework for medical image handling in Julia. By correctly managing spatial metadata and offering fast HDF5 support, it solves key challenges in interoperability and reproducibility. Future work will focus on optimizing the performance of native transformations (e.g., via GPU acceleration using \texttt{CUDA.jl}) and expanding the set of available registration algorithms.

\section*{Conflict of Interest}
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

\section*{Acknowledgements}
We acknowledge the contributions of the JuliaHealth community and the developers of SimpleITK.

\bibliography{bibl}

\section*{Required Metadata}
\label{sec:metadata}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} \\
\hline
C1 & Current code version: v2.0.1 \\
\hline
C2 & Permanent link to code/repository: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C3 & Code Ocean compute capsule: N/A \\
\hline
C4 & Legal Code License: Apache License 2.0 \\
\hline
C5 & Code versioning system used: git \\
\hline
C6 & Software code languages, tools, and services used: Julia, Python (for tests) \\
\hline
C7 & Compilation requirements, operating environments \& dependencies: Julia 1.10+, SimpleITK (tests only) \\
\hline
C8 & If available Link to developer documentation/manual: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C9 & Support email for questions: jakub.mitura14@gmail.com\\
\hline
\end{tabular}
\caption{Code metadata}
\end{table}

\end{document}
