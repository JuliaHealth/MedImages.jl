\documentclass[a4paper,10pt]{elsarticle}

\usepackage{lineno,hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}

\modulolinenumbers[5]

\journal{SoftwareX}

\bibliographystyle{elsarticle-num}

%% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while},%
   sensitive=true,%
   morecomment=[l]{\#},%
   morecomment=[n]{\#=}{=\#},%
   morestring=[b]",%
   morestring=[m]',%
   morestring=[s]{`}{`}%
  }[keywords,comments,strings]

\begin{document}

\begin{frontmatter}

\title{MedImages.jl: A Julia Package for Standardized Medical Image Handling and Spatial Metadata Management}

\author[1]{Jakub Mitura\corref{cor1}}
\ead{jakub.mitura@gmail.com}
\author[1]{Divyansh Goyal}
\ead{divital2004@gmail.com}
\author[1]{Joanna Wybranska}
\ead{}

\cortext[cor1]{Corresponding author}

\address[1]{JuliaHealth}

\begin{abstract}
MedImages.jl addresses the two-language problem in medical imaging by providing native Julia implementations for spatial transformations while preserving clinical metadata through a BIDS-inspired architecture. Unlike Python frameworks (SimpleITK, MONAI) where metadata is lost during NumPy/PyTorch conversion, MedImages.jl enforces zero-cost metadata abstractions via Julia's type system. The package achieves C++-level performance through LLVM JIT compilation while enabling end-to-end automatic differentiation—a capability unavailable in wrapped C++ libraries. By utilizing ITK only for I/O robustness and implementing all transformations in native Julia, the framework ensures full composability with scientific machine learning tools (Flux.jl, Zygote.jl) and supports HDF5-based storage for efficient pipelines. Benchmarks demonstrate 16--180× GPU speedups while maintaining clinical metadata integrity, positioning MedImages.jl as a foundation for physics-informed deep learning in medical imaging.
\end{abstract}

\begin{keyword}
Medical Imaging \sep Julia \sep Spatial Metadata \sep BIDS \sep Differentiable Programming \sep GPU Acceleration \sep Open Source
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Motivation and Significance}

Medical imaging suffers from the two-language problem: researchers prototype in Python but rely on opaque C++ kernels (SimpleITK, ITK) for performance. This creates three critical limitations: (1) \textbf{Metadata Loss}—converting SimpleITK images to NumPy arrays discards spatial metadata (origin, spacing, direction), requiring manual tracking; (2) \textbf{Non-Differentiability}—C++ functions are black boxes to PyTorch's autograd, preventing end-to-end optimization of registration or reconstruction parameters; (3) \textbf{Performance Ceiling}—custom operations require C++/CUDA compilation, creating high-friction development cycles.

MedImages.jl solves these through Julia's unique capabilities. Native Julia code compiles to LLVM machine code, achieving C++ performance without the two-language barrier. The package implements a BIDS-inspired metadata paradigm where spatial context is intrinsic to the data structure via zero-cost type abstractions—metadata travels with pixel data without performance penalty. Critically, all operations are differentiable via Zygote.jl/Enzyme.jl, enabling physics-informed deep learning where MRI reconstruction physics or registration parameters can be optimized jointly with neural networks. GPU acceleration (60--180× speedups) is transparent, requiring no code changes, positioning MedImages.jl as the foundation for next-generation computational medicine.

\section{Software Description}

\subsection{Software Architecture}
MedImages.jl implements a BIDS-inspired metadata paradigm where the \texttt{MedImage} struct enforces metadata integrity through Julia's type system. Unlike Python workflows where \texttt{sitk.GetArrayFromImage()} discards spatial context, MedImages.jl uses zero-cost abstractions—metadata (origin, spacing, direction, patient ID, acquisition timestamp) is intrinsic to the structure without runtime overhead.

A critical design decision: ITK (C++) is used \textit{only} for I/O robustness (NIfTI, DICOM parsing), while \textit{all} transformations are native Julia. This ensures: (1) \textbf{Differentiability}—operations integrate with Zygote.jl/Enzyme.jl for automatic differentiation; (2) \textbf{Composability}—seamless integration with Flux.jl, DifferentialEquations.jl without language barriers; (3) \textbf{Transparency}—users can inspect and extend algorithms without C++ recompilation. The framework handles Julia's column-major (Fortran-style) vs ITK's row-major (C-style) memory layout automatically, abstracting these complexities. SimpleITK validates correctness in tests but is never a runtime dependency.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/architecture.png}
    \caption{Architecture of MedImages.jl. Data loading is handled via ITK C++ wrappers for robustness, while transformations are performed using native Julia libraries. Fast I/O is supported via HDF5.}
    \label{fig:architecture}
\end{figure}

The \texttt{MedImage} struct (Figure \ref{fig:architecture}) implements typed medical imaging semantics:
\begin{itemize}
    \item \texttt{voxel\_data}: Column-major arrays (\texttt{Array\{Float32,3\}} for CT; \texttt{Array\{Float32,4\}} for fMRI time-series)
    \item \texttt{origin}: Physical coordinates $(x,y,z)$ of first voxel (patient reference frame)
    \item \texttt{spacing}: Physical voxel dimensions enabling spatial calculations
    \item \texttt{direction}: Direction cosines for orientation (RAS/LPS coordinate systems)
    \item \texttt{metadata}: DICOM tags, Study/Series UIDs, patient demographics (clinical context persistence)
    \item \texttt{modality}: Strong typing (\texttt{CTImage}, \texttt{PETImage}, \texttt{MRIImage}) enabling dispatch-based processing (automatic HU windowing for CT, SUV colormaps for PET)
\end{itemize}

\subsection{Functionalities}
MedImages.jl provides a comprehensive set of functionalities optimized for 3D medical image processing:

\begin{itemize}
    \item \textbf{Robust I/O:} Loading of various medical image formats (NIfTI, DICOM) using \texttt{ITKIOWrapper}. Transparent handling of 3D volumetric data with automatic metadata extraction.
    
    \item \textbf{Native Julia Transformations:} Functions to modify spatial properties of 3D volumes using \texttt{ImageTransformations.jl} and \texttt{CoordinateTransformations.jl}:
    \begin{itemize}
        \item \texttt{rotate\_mi}: Rotates the 3D volume around a specific axis while updating direction metadata.
        \item \texttt{translate\_mi}: Translates the volume in physical space, updating the origin.
        \item \texttt{scale\_mi}: Resamples the 3D volume to a new scale factor.
        \item \texttt{resample\_to\_spacing}: Changes the voxel spacing to isotropic or custom values (essential for preprocessing pipelines).
        \item \texttt{crop\_mi} and \texttt{pad\_mi}: Modifies the 3D volume extent while preserving spatial metadata.
        \item \texttt{change\_orientation}: Permutes axes and reverses dimensions to convert between anatomical coordinate systems (e.g., RAS, LPS, LPI).
    \end{itemize}
    
    \item \textbf{GPU Acceleration:} All transformations transparently support GPU execution via KernelAbstractions.jl. A $512 \times 512 \times 512$ volume can be resampled 12--16× faster on GPU, or reoriented 60--180× faster, depending on the operation.
    
    \item \textbf{HDF5 Support:} Fast loading and saving of 3D images using the HDF5 format, which significantly speeds up I/O for intermediate processing steps while preserving all spatial metadata. Critical for pipelines processing hundreds of gigabytes of volumetric data.
    
    \item \textbf{Autodifferentiation Support:} All spatial transformations have well-defined gradients via Zygote.jl and Enzyme.jl, enabling differentiable 3D image processing for machine learning applications.
    
    \item \textbf{Orientation Management:} Robust tools to handle and convert between neuroimaging coordinate systems (RAS, LAS, LPI, RPI, etc.), addressing a major source of errors in 3D medical image analysis.
\end{itemize}

\section{Illustrative Examples}

\subsection{Loading and Inspecting an Image}
\begin{lstlisting}[language=Julia]
using MedImages

# Load a NIfTI file
# "CT" specifies the expected image type
med_im = MedImages.load_image("path/to/image.nii.gz", "CT")

# Access voxel data and metadata
println("Origin: ", med_im.origin)
println("Spacing: ", med_im.spacing)
\end{lstlisting}

\subsection{Rotating and Saving with HDF5}
MedImages.jl allows for native rotation and efficient storage using HDF5.

\begin{lstlisting}[language=Julia]
using HDF5

# Rotate 90 degrees around the Z-axis (axis 3)
rotated_im = MedImages.rotate_mi(med_im, 3, 90.0, MedImages.Linear_en)

# Save efficiently using HDF5
h5open("processed_data.h5", "w") do file
    MedImages.save_med_image(file, "patient_001", rotated_im)
end
\end{lstlisting}

\section{Performance Benchmarks}

\subsection{Benchmark Methodology}
MedImages.jl was benchmarked on CPU and GPU backends to demonstrate the framework's performance advantages, particularly for 3D medical imaging where large datasets are commonplace. Benchmarks were conducted on an NVIDIA RTX 3090 GPU with Julia 1.10.10.

\textbf{Configuration:}
\begin{itemize}
    \item \textbf{Synthetic 3D volumes:} Generated volumes of sizes $256 \times 256 \times 128$, $512 \times 512 \times 256$, and $1024 \times 1024 \times 512$ voxels.
    \item \textbf{Sampling:} 10 samples per benchmark with minimum runtime of 2.0 seconds per operation.
    \item \textbf{Interpolation methods:} Both nearest-neighbor and linear interpolation tested.
    \item \textbf{Backends:} Multi-core CPU (24 threads) and CUDA GPU (NVIDIA RTX 3090).
    \item \textbf{Metrics:} Median time, standard deviation, throughput (voxels/s), and speedup ratio (GPU vs CPU).
\end{itemize}

\subsection{Performance Comparison}

Benchmark results for $256 \times 256 \times 128$ volumes comparing MedImages.jl (CPU/GPU) with SimpleITK (CPU baseline). All times in milliseconds.

\begin{table}[H]
\centering
\small
\begin{tabular}{|p{3.2cm}|r|r|r|r|r|}
\hline
\textbf{Operation} & \parbox[t]{1.1cm}{\textbf{Simple\\ITK}} & \parbox[t]{1.1cm}{\textbf{Med\\Images\\CPU}} & \parbox[t]{1.1cm}{\textbf{Med\\Images\\GPU}} & \parbox[t]{0.9cm}{\textbf{GPU vs\\CPU}} & \parbox[t]{0.9cm}{\textbf{GPU vs\\SITK}} \\
\hline
\multicolumn{6}{|l|}{\textit{Resampling (2.0mm spacing)}} \\
\hline
Nearest Neighbor & 8.5 & 7.1 & 0.44 & 16× & 19× \\
Linear & 12.8 & 10.6 & 0.66 & 16× & 19× \\
\hline
\multicolumn{6}{|l|}{\textit{Orientation Changes}} \\
\hline
LAS orientation & 13.2 & 11.7 & 0.10 & 120× & 132× \\
RAS orientation & 12.9 & 11.4 & 0.10 & 116× & 129× \\
RPI orientation & 15.1 & 13.9 & 0.19 & 62× & 79× \\
\hline
\multicolumn{6}{|l|}{\textit{Interpolation (1M points)}} \\
\hline
Nearest Neighbor & 18.5 & 17.2 & 0.14 & 123× & 132× \\
Linear & 36.1 & 34.2 & 0.58 & 59× & 62× \\
\hline
\end{tabular}
\caption{Performance comparison showing MedImages.jl GPU advantages over CPU and SimpleITK baseline. GPU acceleration delivers 16--132× speedups.}
\label{tab:performance}
\end{table}

\subsection{Key Performance Observations}

GPU acceleration is essential for 3D medical imaging: orientation changes achieve 62--132× speedup vs SimpleITK, resampling 16--19×, and large-scale interpolation up to 132×. Speedup increases with volume size—for $1024 \times 1024 \times 512$ volumes, orientation transformations reach 180×. The framework's transparent GPU support via KernelAbstractions.jl requires no code modifications.

\section{Automatic Differentiation and Composability}
\label{sec:autodiff}

\subsection{Importance of Autodifferentiation in Medical Imaging}

Automatic differentiation (AD) is essential for modern medical image analysis, enabling:

\begin{itemize}
    \item \textbf{Differentiable Image Registration:} Computing gradients through spatial transformations allows optimization-based image registration without manual Jacobian computation.
    
    \item \textbf{Neural Network Integration:} Medical image transformations can be composed seamlessly with deep learning frameworks (Flux.jl) for end-to-end training of spatial transformer networks.
    
    \item \textbf{Scientific Machine Learning:} Physics-informed neural networks and inverse problems require gradients through imaging operations.
    
    \item \textbf{Parameter Estimation:} Sensitivity analysis and model fitting require computing derivatives of image processing pipelines.
\end{itemize}

MedImages.jl provides full autodifferentiation support through two complementary mechanisms: Zygote.jl (reverse-mode) and Enzyme.jl (high-performance). This enables researchers to build differentiable medical imaging pipelines without implementing custom gradient rules.

\subsection{Autodifferentiation Implementation}

MedImages.jl implements automatic differentiation through ChainRules.jl (Zygote support via \texttt{rrule} definitions) and Enzyme.jl (GPU kernels). The autodifferentiation test suite validates gradient correctness through numerical comparison, loss function composition, and GPU-CPU consistency, ensuring differentiable medical imaging pipelines.

\section{Quality Assurance and Impact}

MedImages.jl provides rigorous quality assurance through comprehensive testing against SimpleITK (transformations, resampling, metadata preservation, autodifferentiation), ensuring clinical validity. The package solves the two-language problem: researchers write custom filters in Julia achieving C++ performance without compilation delays. Integration with the JuliaHealth ecosystem (MedEye3d.jl for OpenGL visualization, MRIReco.jl for physics-based reconstruction) enables capabilities unavailable in Python—differentiating through MRI reconstruction physics for joint optimization with segmentation networks. GPU acceleration (hours to minutes) enables rapid prototyping, positioning Julia as the platform for physics-informed deep learning in medical imaging.

\section{Conclusions and Future Work}

MedImages.jl provides a robust, standardized, and easy-to-use framework for medical image handling in Julia. By correctly managing spatial metadata and offering fast HDF5 support, it solves key challenges in interoperability and reproducibility. Future work will focus on optimizing the performance of native transformations (e.g., via GPU acceleration using \texttt{CUDA.jl}) and expanding the set of available registration algorithms.

\section*{Conflict of Interest}
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

\section*{Acknowledgements}
We acknowledge the contributions of the JuliaHealth community and the developers of SimpleITK.

\bibliography{bibl}

\section*{Required Metadata}
\label{sec:metadata}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} \\
\hline
C1 & Current code version: v2.0.1 \\
\hline
C2 & Permanent link to code/repository: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C3 & Code Ocean compute capsule: N/A \\
\hline
C4 & Legal Code License: Apache License 2.0 \\
\hline
C5 & Code versioning system used: git \\
\hline
C6 & Software code languages, tools, and services used: Julia, Python (for tests) \\
\hline
C7 & Compilation requirements, operating environments \& dependencies: Julia 1.10+, SimpleITK (tests only) \\
\hline
C8 & If available Link to developer documentation/manual: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C9 & Support email for questions: jakub.mitura14@gmail.com\\
\hline
\end{tabular}
\caption{Code metadata}
\end{table}

\end{document}
