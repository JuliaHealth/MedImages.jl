\documentclass[a4paper,10pt]{elsarticle}

\usepackage{lineno,hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}

\modulolinenumbers[5]

\journal{SoftwareX}

\bibliographystyle{elsarticle-num}

%% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while},%
   sensitive=true,%
   morecomment=[l]{\#},%
   morecomment=[n]{\#=}{=\#},%
   morestring=[b]",%
   morestring=[m]',%
   morestring=[s]{`}{`}%
  }[keywords,comments,strings]

\begin{document}

\begin{frontmatter}

\title{MedImages.jl: A Julia Package for Standardized Medical Image Handling and Spatial Metadata Management}

\author[1]{Jakub Mitura\corref{cor1}}
\ead{jakub.mitura@gmail.com}
\author[1]{Divyansh Goyal}
\ead{divital2004@gmail.com}
\author[1]{Joanna Wybranska}
\ead{}

\cortext[cor1]{Corresponding author}

\address[1]{JuliaHealth}

\begin{abstract}
MedImages.jl is a Julia package designed to address the complexities of medical imaging data handling, specifically focusing on the challenges of spatial metadata (origin, spacing, direction) and the integration of high-performance computing with ease of use. Unlike existing wrappers that rely heavily on Python bindings, MedImages.jl leverages native Julia libraries for core spatial transformations and utilizes a C++ wrapped ITK interface strictly for robust data loading. This architecture ensures full composability within the Julia ecosystem, enabling differentiable programming and integration with scientific machine learning frameworks. The package also introduces efficient HDF5-based storage for fast I/O and metadata preservation. We demonstrate that MedImages.jl provides a robust, standardized framework that simplifies common tasks such as loading, transforming, and saving medical images while boosting researcher productivity and facilitating reproducible science. Benchmarks highlight the significant I/O performance advantages of the implemented HDF5 support.
\end{abstract}

\begin{keyword}
Medical Imaging \sep Julia \sep Spatial Metadata \sep ITK \sep HDF5 \sep Open Source \sep Reproducibility
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Motivation and Significance}

Julia's unified CPU/GPU programming model and the two-language problem it solves make it ideal for medical imaging. Clinical CT/MRI scans contain hundreds of millions of voxels, demanding GPU acceleration—Julia enables transparent GPU computation on the same algorithm without code duplication. However, medical imaging introduces distinct challenges: (1) complex data formats (DICOM) with inconsistent metadata, (2) non-isotropic voxel spacing and varying coordinate systems, and (3) computationally intensive 3D grid transformations. A robust framework must provide correctness in spatial metadata handling, high performance through GPU acceleration, and ease of use.

MedImages.jl achieves these goals natively in Julia. Unlike C++ wrappers (which incur interoperability overhead) or pure-Python approaches (which struggle at scale), MedImages.jl is designed from the ground up for 3D volumetric data with GPU acceleration as a first-class feature. It preserves essential spatial metadata, enables end-to-end differentiable processing via Zygote.jl and Enzyme.jl, and achieves 60--180× speedups on GPUs, making it uniquely suited for modern scientific machine learning in medical imaging.

\section{Software Description}

\subsection{Software Architecture}
MedImages.jl is built to provide a seamless, native interface for medical image processing in Julia. Its core architecture revolves around the \texttt{MedImage} struct, which standardizes the representation of medical image data.

A key design choice is the minimal reliance on external non-Julia dependencies for core processing. While data loading leverages the robust \texttt{ITKIOWrapper} (utilizing the C++ ITK library via JLL packages) to ensure broad format support (NIfTI, DICOM), all spatial transformations are implemented in native Julia. This distinction is crucial as it allows for full composability with other Julia packages, such as \texttt{DifferentialEquations.jl} and \texttt{Flux.jl}, and avoids the overhead and opacity of Python bridges for computational tasks. SimpleITK is utilized exclusively within the test suite to serve as a ground truth for verifying the correctness of the native implementations.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/architecture.png}
    \caption{Architecture of MedImages.jl. Data loading is handled via ITK C++ wrappers for robustness, while transformations are performed using native Julia libraries. Fast I/O is supported via HDF5.}
    \label{fig:architecture}
\end{figure}

The \texttt{MedImage} struct (Figure \ref{fig:architecture}) encapsulates:
\begin{itemize}
    \item \texttt{voxel\_data}: A multidimensional array holding the pixel intensities.
    \item \texttt{origin}: The $(x, y, z)$ physical coordinates of the first voxel.
    \item \texttt{spacing}: The physical distance between voxels in each dimension.
    \item \texttt{direction}: The direction cosines defining the orientation of the image axes.
    \item \texttt{metadata}: Dictionaries storing additional DICOM or NIfTI tags.
\end{itemize}

\subsection{Functionalities}
MedImages.jl provides a comprehensive set of functionalities optimized for 3D medical image processing:

\begin{itemize}
    \item \textbf{Robust I/O:} Loading of various medical image formats (NIfTI, DICOM) using \texttt{ITKIOWrapper}. Transparent handling of 3D volumetric data with automatic metadata extraction.
    
    \item \textbf{Native Julia Transformations:} Functions to modify spatial properties of 3D volumes using \texttt{ImageTransformations.jl} and \texttt{CoordinateTransformations.jl}:
    \begin{itemize}
        \item \texttt{rotate\_mi}: Rotates the 3D volume around a specific axis while updating direction metadata.
        \item \texttt{translate\_mi}: Translates the volume in physical space, updating the origin.
        \item \texttt{scale\_mi}: Resamples the 3D volume to a new scale factor.
        \item \texttt{resample\_to\_spacing}: Changes the voxel spacing to isotropic or custom values (essential for preprocessing pipelines).
        \item \texttt{crop\_mi} and \texttt{pad\_mi}: Modifies the 3D volume extent while preserving spatial metadata.
        \item \texttt{change\_orientation}: Permutes axes and reverses dimensions to convert between anatomical coordinate systems (e.g., RAS, LPS, LPI).
    \end{itemize}
    
    \item \textbf{GPU Acceleration:} All transformations transparently support GPU execution via KernelAbstractions.jl. A $512 \times 512 \times 512$ volume can be resampled 12--16× faster on GPU, or reoriented 60--180× faster, depending on the operation.
    
    \item \textbf{HDF5 Support:} Fast loading and saving of 3D images using the HDF5 format, which significantly speeds up I/O for intermediate processing steps while preserving all spatial metadata. Critical for pipelines processing hundreds of gigabytes of volumetric data.
    
    \item \textbf{Autodifferentiation Support:} All spatial transformations have well-defined gradients via Zygote.jl and Enzyme.jl, enabling differentiable 3D image processing for machine learning applications.
    
    \item \textbf{Orientation Management:} Robust tools to handle and convert between neuroimaging coordinate systems (RAS, LAS, LPI, RPI, etc.), addressing a major source of errors in 3D medical image analysis.
\end{itemize}

\section{Illustrative Examples}

\subsection{Loading and Inspecting an Image}
\begin{lstlisting}[language=Julia]
using MedImages

# Load a NIfTI file
# "CT" specifies the expected image type
med_im = MedImages.load_image("path/to/image.nii.gz", "CT")

# Access voxel data and metadata
println("Origin: ", med_im.origin)
println("Spacing: ", med_im.spacing)
\end{lstlisting}

\subsection{Rotating and Saving with HDF5}
MedImages.jl allows for native rotation and efficient storage using HDF5.

\begin{lstlisting}[language=Julia]
using HDF5

# Rotate 90 degrees around the Z-axis (axis 3)
rotated_im = MedImages.rotate_mi(med_im, 3, 90.0, MedImages.Linear_en)

# Save efficiently using HDF5
h5open("processed_data.h5", "w") do file
    MedImages.save_med_image(file, "patient_001", rotated_im)
end
\end{lstlisting}

\section{Performance Benchmarks}

\subsection{Benchmark Methodology}
MedImages.jl was benchmarked on CPU and GPU backends to demonstrate the framework's performance advantages, particularly for 3D medical imaging where large datasets are commonplace. Benchmarks were conducted on an NVIDIA RTX 3090 GPU with Julia 1.10.10.

\textbf{Configuration:}
\begin{itemize}
    \item \textbf{Synthetic 3D volumes:} Generated volumes of sizes $256 \times 256 \times 128$, $512 \times 512 \times 256$, and $1024 \times 1024 \times 512$ voxels.
    \item \textbf{Sampling:} 10 samples per benchmark with minimum runtime of 2.0 seconds per operation.
    \item \textbf{Interpolation methods:} Both nearest-neighbor and linear interpolation tested.
    \item \textbf{Backends:} Multi-core CPU (24 threads) and CUDA GPU (NVIDIA RTX 3090).
    \item \textbf{Metrics:} Median time, standard deviation, throughput (voxels/s), and speedup ratio (GPU vs CPU).
\end{itemize}

\subsection{Performance Comparison}

Benchmark results for $256 \times 256 \times 128$ volumes comparing MedImages.jl (CPU/GPU) with SimpleITK (CPU baseline). All times in milliseconds.

\begin{table}[H]
\centering
\small
\begin{tabular}{|p{3.2cm}|r|r|r|r|r|}
\hline
\textbf{Operation} & \parbox[t]{1.1cm}{\textbf{Simple\\ITK}} & \parbox[t]{1.1cm}{\textbf{Med\\Images\\CPU}} & \parbox[t]{1.1cm}{\textbf{Med\\Images\\GPU}} & \parbox[t]{0.9cm}{\textbf{GPU vs\\CPU}} & \parbox[t]{0.9cm}{\textbf{GPU vs\\SITK}} \\
\hline
\multicolumn{6}{|l|}{\textit{Resampling (2.0mm spacing)}} \\
\hline
Nearest Neighbor & 8.5 & 7.1 & 0.44 & 16× & 19× \\
Linear & 12.8 & 10.6 & 0.66 & 16× & 19× \\
\hline
\multicolumn{6}{|l|}{\textit{Orientation Changes}} \\
\hline
LAS orientation & 13.2 & 11.7 & 0.10 & 120× & 132× \\
RAS orientation & 12.9 & 11.4 & 0.10 & 116× & 129× \\
RPI orientation & 15.1 & 13.9 & 0.19 & 62× & 79× \\
\hline
\multicolumn{6}{|l|}{\textit{Interpolation (1M points)}} \\
\hline
Nearest Neighbor & 18.5 & 17.2 & 0.14 & 123× & 132× \\
Linear & 36.1 & 34.2 & 0.58 & 59× & 62× \\
\hline
\end{tabular}
\caption{Performance comparison showing MedImages.jl GPU advantages over CPU and SimpleITK baseline. GPU acceleration delivers 16--132× speedups.}
\label{tab:performance}
\end{table}

\subsection{Key Performance Observations}

GPU acceleration is essential for 3D medical imaging: orientation changes achieve 62--132× speedup vs SimpleITK, resampling 16--19×, and large-scale interpolation up to 132×. Speedup increases with volume size—for $1024 \times 1024 \times 512$ volumes, orientation transformations reach 180×. The framework's transparent GPU support via KernelAbstractions.jl requires no code modifications.

\section{Automatic Differentiation and Composability}
\label{sec:autodiff}

\subsection{Importance of Autodifferentiation in Medical Imaging}

Automatic differentiation (AD) is essential for modern medical image analysis, enabling:

\begin{itemize}
    \item \textbf{Differentiable Image Registration:} Computing gradients through spatial transformations allows optimization-based image registration without manual Jacobian computation.
    
    \item \textbf{Neural Network Integration:} Medical image transformations can be composed seamlessly with deep learning frameworks (Flux.jl) for end-to-end training of spatial transformer networks.
    
    \item \textbf{Scientific Machine Learning:} Physics-informed neural networks and inverse problems require gradients through imaging operations.
    
    \item \textbf{Parameter Estimation:} Sensitivity analysis and model fitting require computing derivatives of image processing pipelines.
\end{itemize}

MedImages.jl provides full autodifferentiation support through two complementary mechanisms: Zygote.jl (reverse-mode) and Enzyme.jl (high-performance). This enables researchers to build differentiable medical imaging pipelines without implementing custom gradient rules.

\subsection{Autodifferentiation Implementation}

MedImages.jl implements automatic differentiation through ChainRules.jl (Zygote support via \texttt{rrule} definitions) and Enzyme.jl (GPU kernels). The autodifferentiation test suite validates gradient correctness through numerical comparison, loss function composition, and GPU-CPU consistency, ensuring differentiable medical imaging pipelines.

\section{Quality Assurance and Impact}

MedImages.jl provides rigorous quality assurance through comprehensive testing against SimpleITK (transformations, resampling, metadata preservation, autodifferentiation), ensuring clinical validity. The package eliminates language switching—researchers perform end-to-end analysis in Julia—and GPU acceleration reduces preprocessing from hours to minutes, enabling rapid iteration on algorithm development.

\section{Conclusions and Future Work}

MedImages.jl provides a robust, standardized, and easy-to-use framework for medical image handling in Julia. By correctly managing spatial metadata and offering fast HDF5 support, it solves key challenges in interoperability and reproducibility. Future work will focus on optimizing the performance of native transformations (e.g., via GPU acceleration using \texttt{CUDA.jl}) and expanding the set of available registration algorithms.

\section*{Conflict of Interest}
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

\section*{Acknowledgements}
We acknowledge the contributions of the JuliaHealth community and the developers of SimpleITK.

\bibliography{bibl}

\section*{Required Metadata}
\label{sec:metadata}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} \\
\hline
C1 & Current code version: v2.0.1 \\
\hline
C2 & Permanent link to code/repository: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C3 & Code Ocean compute capsule: N/A \\
\hline
C4 & Legal Code License: Apache License 2.0 \\
\hline
C5 & Code versioning system used: git \\
\hline
C6 & Software code languages, tools, and services used: Julia, Python (for tests) \\
\hline
C7 & Compilation requirements, operating environments \& dependencies: Julia 1.10+, SimpleITK (tests only) \\
\hline
C8 & If available Link to developer documentation/manual: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C9 & Support email for questions: jakub.mitura14@gmail.com\\
\hline
\end{tabular}
\caption{Code metadata}
\end{table}

\end{document}
