\documentclass[a4paper,10pt]{elsarticle}

\usepackage{lineno,hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage{longtable}

\modulolinenumbers[5]

\journal{SoftwareX}

\bibliographystyle{elsarticle-num}

%% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while},%
   sensitive=true,%
   morecomment=[l]{\#},%
   morecomment=[n]{\#=}{=\#},%
   morestring=[b]",%
   morestring=[m]',%
   morestring=[s]{`}{`}%
  }[keywords,comments,strings]

\begin{document}

\begin{frontmatter}

\title{MedImages.jl: A Julia Package for Standardized Medical Image Handling and Spatial Metadata Management}

\author[1]{Jakub Mitura\corref{cor1}}
\ead{jakub.mitura@gmail.com}
\author[1]{Divyansh Goyal}
\ead{divital2004@gmail.com}

\cortext[cor1]{Corresponding author}

\address[1]{JuliaHealth}

\begin{abstract}
MedImages.jl is a Julia package designed to address the complexities of medical imaging data handling, specifically focusing on the challenges of spatial metadata (origin, spacing, direction) and the integration of high-performance computing with ease of use. Leveraging the Julia programming language's capabilities and integrating with the robust SimpleITK library via PyCall, MedImages.jl provides a standardized \texttt{MedImage} structure that encapsulates voxel data alongside its critical spatial context. This article describes the software's architecture, which bridges the gap between the flexible, high-level syntax of Julia and established low-level medical imaging standards. We demonstrate how MedImages.jl simplifies common tasks such as loading, transforming, and saving medical images (NIfTI, DICOM) while ensuring spatial consistency. The package aims to democratize access to medical image processing by providing a performant, open-source tool that boosts researcher productivity and facilitates reproducible science.
\end{abstract}

\begin{keyword}
Medical Imaging \sep Julia \sep Spatial Metadata \sep SimpleITK \sep Open Source \sep Reproducibility
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Motivation and Significance}

\subsection{The Role of Julia in Scientific Computing}
Julia is a high-level, dynamic programming language designed to bridge the gap between easy-to-use languages like Python and R, and high-performance languages like C++ and Fortran \cite{PalBhattacharya2024,BelyakovaChung2020}. It solves the "two-language problem," where researchers prototype in a high-level language but must rewrite performance-critical code in a low-level language \cite{EschleGl2023,KnoppGrosser2021}. Julia combines the ease of a productivity language with the speed of a performance language, featuring a Just-In-Time (JIT) compiler, multiple dispatch, and built-in support for parallel computing \cite{SiscoWang2022,PalBhattacharya2024}. This makes it an ideal platform for scientific computing, particularly in computationally intensive fields like medical imaging.

\subsection{Challenges in Medical Imaging Formats}
Medical imaging data presents unique difficulties compared to standard images. Formats like DICOM are notoriously complex, with elaborate structures and porous metadata requirements \cite{BridgeGorman2022}. A critical challenge is the handling of spatial metadata—spacing, direction, and origin—which defines the image's physical location and orientation relative to the patient \cite{YanivLowekamp2017}. Unlike standard images, medical images often have non-isotropic voxel spacing and lack a universal coordinate system \cite{UnknownAuthor2011}. Ignoring this spatial information can lead to invalid operations and loss of clinical context \cite{YanivLowekamp2017,BridgeGorman2022}. Researchers often struggle with inconsistent image headers and the need for specialized tools to handle basic I/O and preprocessing \cite{UnknownAuthor2020,CardosoLi2022}.

\subsection{The Importance of Standardized Open Source Tools}
Standardized open-source tools are essential for democratizing access to medical image processing. They boost productivity by abstracting the complexity of standards like DICOM and ensuring that spatial metadata is handled consistently \cite{LowekampChen2013,SandkhlerJud2018}. Tools like SimpleITK have lowered the barrier to entry by providing simplified interfaces to complex algorithms \cite{LowekampChen2013}. Furthermore, open-source libraries foster reproducibility and trustworthiness in research by allowing code scrutiny and facilitating version control \cite{SchindelinRueden2015,CardosoLi2022}. They bridge the gap between research and clinical deployment by ensuring interoperability with clinical systems and preserving essential metadata \cite{BridgeGorman2022}.

\section{Software Description}

\subsection{Software Architecture}
MedImages.jl is built to provide a seamless interface for medical image processing in Julia. Its core architecture revolves around the \texttt{MedImage} struct, which standardizes the representation of medical image data.

The architecture leverages Julia's interoperability features to integrate with the industry-standard ITK C++ libraries via \texttt{ITKIOWrapper.jl} for robust file I/O operations (supporting DICOM, NIfTI, etc.). Crucially, unlike wrapper libraries that rely on C++ or Python backends for processing, MedImages.jl implements all image processing algorithms (transformations, resampling, interpolation) in native Julia. This design choice ensures full composability with the Julia ecosystem and allows for future GPU acceleration and automatic differentiation. SimpleITK is used exclusively for testing and validation purposes to ensure the correctness of the native implementation.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/architecture.png}
    \caption{Architecture of MedImages.jl illustrating the data flow from file loading to the \texttt{MedImage} struct, transformation via SimpleITK backend, and saving.}
    \label{fig:architecture}
\end{figure}

The \texttt{MedImage} struct (Figure \ref{fig:architecture}) encapsulates:
\begin{itemize}
    \item \texttt{voxel\_data}: A multidimensional array holding the pixel intensities.
    \item \texttt{origin}: The $(x, y, z)$ physical coordinates of the first voxel.
    \item \texttt{spacing}: The physical distance between voxels in each dimension.
    \item \texttt{direction}: The direction cosines defining the orientation of the image axes.
    \item \texttt{metadata}: Dictionaries storing additional DICOM or NIfTI tags.
\end{itemize}

\subsection{Functionalities}
MedImages.jl provides a comprehensive set of functionalities for medical image handling:

\begin{itemize}
    \item \textbf{I/O Operations:} Loading and saving of various medical image formats (NIfTI, DICOM) using \texttt{load\_image} and \texttt{save\_med\_image}.
    \item \textbf{Spatial Transformations:} Functions to modify the spatial properties of images, including:
    \begin{itemize}
        \item \texttt{rotate\_mi}: Rotates the image around a specific axis.
        \item \texttt{translate\_mi}: Translates the image in physical space.
        \item \texttt{scale\_mi}: Resamples the image to a new scale.
        \item \texttt{resample\_to\_spacing}: Changes the voxel spacing.
        \item \texttt{crop\_mi} and \texttt{pad\_mi}: Modifies the image extent.
    \end{itemize}
    \item \textbf{Orientation Management:} Tools to handle and convert image orientations (e.g., RAS, LPS).
    \item \textbf{Metadata Management:} Ensuring that spatial metadata is correctly updated during all transformations to maintain physical consistency.
    \item \textbf{HDF5 Support:} To address the need for fast I/O and metadata preservation during intermediate processing steps, MedImages.jl provides support for the HDF5 format. This allows researchers to save the \texttt{MedImage} struct (including complex nested metadata) efficiently, bypassing the parsing overhead of DICOM for intermediate results.
\end{itemize}

\section{Validation and Testing}
The correctness of MedImages.jl is rigorously validated against SimpleITK, a gold-standard library in the field. The test suite performs side-by-side comparisons of operations such as rotation, cropping, and resampling, ensuring that the native Julia implementation yields results consistent with established C++ tools. This approach guarantees that the spatial metadata handling adheres to the physical space tenets required for clinical accuracy.

\section{Performance Benchmarks}
We compared the performance of MedImages.jl (native Julia) against SimpleITK (C++ wrapped in Python) for standard operations. The benchmarks were run on a system with 4 CPU cores, with Julia configured to use multi-threading (`-t auto`).

\begin{table}[H]
\centering
\begin{tabular}{lrrr}
\toprule
\textbf{Operation} & \textbf{MedImages.jl (s)} & \textbf{SimpleITK (s)} & \textbf{Ratio (MI/SITK)} \\
\midrule
Load Image & 0.82 & 0.47 & 1.75x \\
Rotation (90$^\circ$) & 1.37 & 0.17 & 8.14x \\
Resampling & 0.56 & 0.13 & 4.26x \\
\bottomrule
\end{tabular}
\caption{Performance comparison. MedImages.jl leverages KernelAbstractions.jl for resampling, achieving significant speedups through multi-threading (4 threads). While SimpleITK's highly optimized C++ backend remains faster, the native Julia implementation offers competitive performance with the added benefit of being backend-agnostic (CPU/GPU) and differentiable.}
\label{tab:benchmarks}
\end{table}

\section{Illustrative Examples}

Here we demonstrate the basic usage of MedImages.jl for loading a medical image, performing a rotation, and saving the result. This workflow highlights how the package abstracts the complexity of spatial metadata handling.

\subsection{Loading and Inspecting an Image}
\begin{lstlisting}[language=Julia]
using MedImages

# Load a NIfTI file
# "CT" specifies the expected image type
med_im = MedImages.load_image("path/to/image.nii.gz", "CT")

# Access voxel data and metadata
println("Origin: ", med_im.origin)
println("Spacing: ", med_im.spacing)
println("Direction: ", med_im.direction)
\end{lstlisting}

\subsection{Resampling an Image}
Resampling is often necessary when registering images from different sources. MedImages.jl allows users to resample an image to a new voxel spacing while handling the interpolation of intensity values.

\begin{lstlisting}[language=Julia]
# Define target spacing (e.g., isotropic 1mm)
new_spacing = (1.0, 1.0, 1.0)

# Resample using linear interpolation
resampled_im = MedImages.resample_to_spacing(med_im, new_spacing, MedImages.Linear_en)

println("New Spacing: ", resampled_im.spacing)
\end{lstlisting}

\subsection{Rotating an Image}
The following example shows how to rotate an image by 90 degrees around the Z-axis (axis 3). The function automatically handles interpolation and updates the direction matrix.

\begin{lstlisting}[language=Julia]
# Rotate 90 degrees around the 3rd axis (Z-axis)
# Using Linear interpolation
rotated_im = MedImages.rotate_mi(med_im, 3, 90.0, MedImages.Linear_en)

# The direction cosines are updated automatically
println("New Direction: ", rotated_im.direction)
\end{lstlisting}

\subsection{Saving the Result}
Finally, the processed image can be saved back to disk. The spatial metadata is preserved in the output file.

\begin{lstlisting}[language=Julia]
# Save the rotated image
MedImages.save_med_image(rotated_im, "path/to/rotated_image.nii.gz")
\end{lstlisting}

\section{Impact}

MedImages.jl contributes to the growing ecosystem of Julia tools for medical imaging. By providing a native Julia interface to established libraries like SimpleITK, it empowers researchers to leverage Julia's high performance and expressiveness without losing access to standard industry tools.

\subsection{Boosting Productivity}
The package helps boost productivity by eliminating the need to switch between languages (the two-language problem). Researchers can perform end-to-end analysis—from data loading to complex modeling and simulation (e.g., using SciML)—within the Julia environment. This streamlines workflows and reduces the cognitive load associated with managing multiple programming environments \cite{PalBhattacharya2024,KnoppGrosser2021}.

\subsection{Democratizing Access}
By abstracting the complexities of the DICOM standard and spatial metadata math, MedImages.jl democratizes access to correct medical image processing. Users do not need to be experts in affine transformations or file format specifications to perform valid operations. This is crucial for interdisciplinary research where domain experts (e.g., biologists, clinicians) may not have deep software engineering expertise \cite{LowekampChen2013}.

\subsection{Potential for New Methods}
Julia's potential for medical imaging is significant, with libraries like MRIReco.jl and KomaMRI.jl already demonstrating performance comparable to C/C++ \cite{KnoppGrosser2021,HeideBerg2024}. For instance, a Julia-based toolkit for Selective Inversion Recovery (SIR) MRI parameter estimation showed a 20-fold reduction in computational time compared to a previous MATLAB implementation \cite{SiscoWang2022}. MedImages.jl supports this ecosystem by providing the foundational data structures and I/O capabilities required to build advanced analysis pipelines, such as those involving automatic differentiation or machine learning integration.

\section{Discussion and Future Work}

MedImages.jl fills a critical gap in the Julia ecosystem by providing a native, high-performance tool for medical image manipulation. While wrappers for ITK exist, a pure Julia implementation offers better integration with other Julia packages, such as \texttt{DifferentialEquations.jl} or \texttt{Flux.jl}, allowing for end-to-end differentiable pipelines.

One of the key advantages of MedImages.jl is its lightweight nature compared to heavy dependencies. By implementing core functionalities in native Julia, it allows for easier deployment. Furthermore, the potential for GPU acceleration using Julia's \texttt{CUDA.jl} or \texttt{AMDGPU.jl} packages is a significant area for future development. The \texttt{MedImage} struct is designed with this in mind, with a \texttt{current\_device} field to track where the data resides.

Future work will focus on:
\begin{itemize}
    \item \textbf{GPU Integration:} Fully leveraging Julia's GPU capabilities for resampling and transformation operations.
    \item \textbf{Advanced Registration:} Implementing intensity-based registration algorithms natively in Julia.
    \item \textbf{Deep Learning Integration:} Creating seamless bridges to \texttt{Flux.jl} and \texttt{Lux.jl} for medical image segmentation and reconstruction tasks.
\end{itemize}

\section{Conclusions}

MedImages.jl provides a robust, standardized, and easy-to-use framework for medical image handling in Julia. By correctly managing spatial metadata and integrating with SimpleITK, it solves key challenges in the field, including interoperability and reproducibility. As the Julia medical imaging ecosystem grows, MedImages.jl aims to serve as a foundational tool for researchers and developers.

\section*{Conflict of Interest}
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

\section*{Acknowledgements}
We acknowledge the contributions of the JuliaHealth community and the developers of SimpleITK.

\bibliography{bibl}

\section*{Required Metadata}
\label{sec:metadata}

\begin{table}[H]
\begin{tabular}{|l|p{6.5cm}|}
\hline
\textbf{Nr.} & \textbf{Code metadata description} \\
\hline
C1 & Current code version: v2.0.1 \\
\hline
C2 & Permanent link to code/repository: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C3 & Code Ocean compute capsule: N/A \\
\hline
C4 & Legal Code License: Apache License 2.0 \\
\hline
C5 & Code versioning system used: git \\
\hline
C6 & Software code languages, tools, and services used: Julia, Python \\
\hline
C7 & Compilation requirements, operating environments \& dependencies: Julia 1.10+, SimpleITK \\
\hline
C8 & If available Link to developer documentation/manual: https://github.com/JuliaHealth/MedImages.jl \\
\hline
C9 & Support email for questions: jakub.mitura@gmail.com \\
\hline
\end{tabular}
\caption{Code metadata}
\end{table}

\end{document}
